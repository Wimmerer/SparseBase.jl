var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = SparseBase","category":"page"},{"location":"#SparseBase","page":"Home","title":"SparseBase","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for SparseBase.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [SparseBase]","category":"page"},{"location":"#SparseBase.filltype-Tuple{AbstractArray}","page":"Home","title":"SparseBase.filltype","text":"filltype(A)\n\nType of implicit values of A. Most arrays either have no fill, or only support fill in the same domain as eltype(A).\n\n\n\n\n\n","category":"method"},{"location":"#SparseBase.fkeep!","page":"Home","title":"SparseBase.fkeep!","text":"fkeep!(f, [C], A)\n\nKeep values of A where f is true. f(i..., x)::Bool\n\n\n\n\n\n","category":"function"},{"location":"#SparseBase.getfill","page":"Home","title":"SparseBase.getfill","text":"getfill(A)\n\nThe value taken by all non-stored/implicit indices of A.\n\n\n\n\n\n","category":"function"},{"location":"#SparseBase.hasfixedsparsity-Tuple{Any}","page":"Home","title":"SparseBase.hasfixedsparsity","text":"hasfixedsparsity(::Type{A})::Bool\n\nTrue if the sparsity pattern of the type A may be changed. A Diagonal type, for instance, may not have its sparsity pattern changed.\n\n\n\n\n\n","category":"method"},{"location":"#SparseBase.haszerobasedinternals-Tuple{SparseBase.AbstractSparseArray}","page":"Home","title":"SparseBase.haszerobasedinternals","text":"haszerobasedinternals(::Type{A})::Bool\n\nTrue if a type has zero based internal vectors.\n\nThis does not indicate that A is indexed in a zero-based manner, Instead, the internal representation is zero based. This is useful if C libraries implement much of the functionality of A, or A is frequently based to 0 based solvers.\n\n\n\n\n\n","category":"method"},{"location":"#SparseBase.isisovalued-Tuple{Any}","page":"Home","title":"SparseBase.isisovalued","text":"isisovalued(A)::Bool\n\nTrue if a type contains a single value across all explicit indices.\n\n\n\n\n\n","category":"method"},{"location":"#SparseBase.isopaque-Tuple{Any}","page":"Home","title":"SparseBase.isopaque","text":"isopaque(::Type{A})::Bool\n\nTrue if internals may not be accessed directly. C owned types often set this to true.\n\n\n\n\n\n","category":"method"},{"location":"#SparseBase.issparse-Tuple{Any}","page":"Home","title":"SparseBase.issparse","text":"issparse(::T)::Bool\nissparse(::DataType{T})::Bool\n\ntrue if T is a sparse type. A sparse container is still considered sparse if all indices are explicitly stored.\n\n\n\n\n\n","category":"method"},{"location":"#SparseBase.mapstored!","page":"Home","title":"SparseBase.mapstored!","text":"mapstored[!](f, [C], A)\nmapstored(f, A ∪ B)\nmapstored(f, (A ∩ B) ∪ C)\n\nMap a function over the stored values of A(, B, C, ...).\n\nUnions and intersections of A, B, C... operate elementwise over the unions and intersections of the patterns of those matrices.\n\nTBD: \n\neadd in GraphBLAS doesn't work here, we need some notion of \"passthrough\".\n\nmissing doesn't work since missing + 2.0 = missing. GraphBLAS wants some ability to do NONSTORED + 2.0 = 2.0 for the eadd operation.\n\nThis could potentially lead to wrapper hell. I hope it doesn't, I think we would have\n\nUnionPattern, IntersectionPattern (maybe ComplementPattern?). I don't think these wrappers are quite as bad as the ones in LinAlg, but I could be wrong.\n\nCurrent implementations (SSGrB) only implement `mapstored!\n\n\n\n\n\n","category":"function"},{"location":"#SparseBase.nstored-Tuple{Any}","page":"Home","title":"SparseBase.nstored","text":"nstored(A)::Integer\n\nNumber of stored elements in A. In the dense case this is length(A)\n\n\n\n\n\n","category":"method"},{"location":"#SparseBase.setfill","page":"Home","title":"SparseBase.setfill","text":"setfill!(A)::A\nsetfill(A)::B\n\nSet the value taken by implicit indices of A to a new value. setfill produces a shallow copy of A with the new fill value.\n\n\n\n\n\n","category":"function"},{"location":"#SparseBase.storedindices","page":"Home","title":"SparseBase.storedindices","text":"storedindices(A)\n\nAn iterable over the stored indices of A. May be a direct view into internals, but is invalid to modify. May be a lazy iterator.\n\nReturned indices should be a tuple (SoA) form.\n\n\n\n\n\n","category":"function"},{"location":"#SparseBase.storedvalues","page":"Home","title":"SparseBase.storedvalues","text":"storedvalues(A)\n\nAn iterable over the stored values of A. May be a direct view into internals,  but this is not a requirement, and so shouldn't be used to modify A.\n\n\n\n\n\n","category":"function"}]
}
